# -*- coding: utf-8 -*-

"""factory.py:
This module provides the Factory class for Bokeh UI widgets for 
testing and controlling 2D image sensors
"""

__author__ = "Zhi Zi"
__email__ = "x@zzi.io"
__version__ = "20221103"


from functools import wraps, partial
from bokeh.models.widgets import RadioButtonGroup, Button, TextInput, FileInput
from bokeh.layouts import column
from .remote import RemoteCamera
from .utils import ignore_connection_error


class BundleBokehCamera:
    """
    This class is responsible for holding references to the Bokeh UI Widgets
    and corresponding functions of a single image sensor.
    """

    def __init__(self) -> None:
        init_str = 'Initialize at {}'.format(self)
        self.test_online = Button(label="Test camera online")
        # self.select_mode = RadioButtonGroup(labels=[init_str, init_str])
        # self.sample_size = TextInput(title=init_str)
        self.manual_take_sample = Button(
            label='Take Photo', button_type='warning')
        self.preview_image = None
        self.get_image = None

    def quick_control_group(self):
        widget_list = [
            self.test_online,
            # self.select_mode,
            # self.sample_size,
            self.manual_take_sample,
        ]
        return column(*widget_list)


class FactoryCamera:
    """
    The factory class is responsible to generate all interaction elements and backend APIs
    for a camera type component according to a given bundle configuration, and packs all
    generated stuff in a pre-defined bundle.

    Note that a bundle configuration is different from a lab config in that it is very likely
    un-serializable to JSON, because the config probably holds references to arrays or other
    object references.
    The bundle config is only generated in-place when bundle generation is required by a higher
    level application, so it is not needed to be serialized or stored or transfered to other
    applications or modules anyway.
    Lab configs, in contrast, must always be serializable and is passed around everywhere.

    We assume the higher-level application knows how to use the object when it requires a 
    specific type of bundle by specifying the bundle type in the bundle config. Although
    generated by the same generate_bundle method,  
    """

    def __init__(self, lcfg, lstat) -> None:
        self.lcfg = lcfg
        self.lstat = lstat

    def generate_bundle(self, bundle_config):
        camera_name = bundle_config["Name"]
        # if bundle_config["BundleType"] == "Bokeh":
        preview_image = bundle_config["PreviewImage"]
        return self.generate_bundle_bokeh(camera_name, preview_image)


    def generate_bundle_bokeh(self, camera_name, preview_image) -> BundleBokehCamera:
        bundle = BundleBokehCamera()
        bundle.preview_image = preview_image # BundleImageRGBA
        config = self.lcfg.config["cameras"][camera_name]
        remote = RemoteCamera(config)

        def __callback_test_online():
            try:
                self.lstat.fmtmsg(remote.online())
            except Exception as inst:
                print(type(inst), inst.args)
                self.lstat.expmsg(
                    "[Error] Nothing from remote, server is probably down.")

        bundle.test_online.on_click(__callback_test_online)

        @ignore_connection_error
        def __callback_manual_take_sample():
            new_image = remote.get_image()
            xmin = 0
            ymin = 0
            xmax = new_image.shape[1]
            ymax = new_image.shape[0]
            self.lstat.doc.add_next_tick_callback(
                partial(bundle.preview_image.callback_update,
                        new_image,
                        xmin, xmax,
                        ymin, ymax)
            )

        bundle.manual_take_sample.on_click(__callback_manual_take_sample)

        def __get_image():
            result = remote.get_image()
            return result

        bundle.get_image = __get_image

        return bundle
